---
typora-copy-images-to: ./assets
typora-root-url: ./assets
---

## 基础知识

### 环境变量

Environment Variable
运行一个命令或者程序时，系统默认在当前路径下查找，再去环境变量中查找。
配置环境变量的作用：即可以在任意路径下执行该命令/程序。

可用**本地变量**优先于环境变量，产生临时生效的效果。

classpath：jvm启动类的路径，可多值，用分号隔开。

### .class和.java文件

**.java**：我们编写的文件

**.class**：.java-->javac编译后的字节码文件，是**真正由JVM运行的文件**，可以运行在任何的JVM虚拟机上(即：一次编译，多出运行。但JVM本身不是跨平台的，linux和win上的JVM是有区别的)

**jar包的作用**：其实就是把.class文件放到一个文件夹中，方便第三方使用。

## 面向对象

概念：你充电话费是面向过程，而你女朋友充电话费就是面向对象。
特征：封装、继承、多态

### 成员变量&局部变量

区别：

成员变量---定义在类中，是'类信息'----整个类都能访问---存在于实例对象中，也即堆内存中---生命周期随GC---有**默认初始化**值

局部变量---定义在函数/语句/代码块中---只在所属区域有效---存在于方法中，也即栈内存中---生命周期随栈帧---无默认初始化值

小结：**局部变量可以说是服务于成员变量**，例如我们常见场景，都是方法中的局部变量赋予对象中的某个属性，来改变对象。**面向对象设计的程序，对象是程序的细胞，数据是程序的血液**。

注意：局部变量与成员变量尽量不要同名，同名时局部优先。

### 基本数据类型传递和引用数据类型传递

<img src="/image-20200423005619196.png" alt="image-20200423005619196" style="zoom:80%;" />

本质的差异是引用数据类型传递的是**对象的地址**，所以不同的方法操作的是同一个对象。

### 封装概念

概念：隐藏对象的属性，提供公共的访问方式（getter、setter）。所以常见类的属性都有private修饰。包括**接口、内部类**都是封装思想的体现。

### 权限修饰符

> **权限修饰符修饰成员**（成员变量和成员方法）

![image-20200423011111363](/image-20200423011111363.png)

同一package：必须是同一文件夹，在子文件夹中都不行。

**常见两点：private，只在当前类有效。要想其他类都能访问，必须public**。

### 构造函数

**作用**：构造函数的使命就是给对象初始化。构造函数与成员函数是有明显的差异性。

**特点**：

1. 函数名与类名相同；

2. 无返回值类型，也无返回值。**一旦加了返回值类型，则为一般函数，不会报错**；

3. 无显式定义构造函数时，有默认的无参构造函数；有显式则无默认无参；

4. 构造函数也会进栈，对象开辟内存空间后调用构造函数对自身进行了“构造函数初始化”；

5. 构造函数里可以调用其他方法，但其他方法肯定是不能调用构造函数；

   举个极端点的例子：一般方法与构造方法同名，且在构造方法中调用了这个同名方法。通过这个例子可以看出构造函数是不受一般函数影响的。

   ```java
   public class ConDemo {
   
   	private String name;
   	private int age;
   
   	public	ConDemo() {
   		super();
   		ConDemo();
   	}
   	public void ConDemo() {
   		System.out.println("123");
   	}
   	public static void main(String[] args) {
   		ConDemo conDemo = new ConDemo();// 输出123
   		conDemo.ConDemo();// 还会输出123
   	}
   }
   ```

6. 构造函数不存在覆盖和继承；


#### 构造代码块

1. 反编译后，发现构造代码块的内容**会出现在各个构造函数中的前部**。所以构造代码块的执行顺序是优先构造函数的。

### this

> **指向的是当前对象的引用**。

**作用：**

1. this.变量 ：用来区分重名的成员变量和局部变量；
2. this.方法：this就是该对象的引用。区分到底是哪个对象调用了此方法。

**话外**：一个成员函数、成员属性一定是被对象调用，不会平白出现。构造函数也是被对象调用，用来对对象自身进行初始化。除了static成员之外。

**没有用this的情况**：

<img src="/image-20200428220231852.png" alt="image-20200428220231852" style="zoom:50%;" />

### static

**作用**：

1. 成员修饰符（成员变量、成员方法），不能修饰局部变量。
2. 静态代码块。

**特点**：

1. 数据共享
2. static修饰的成员随类的加载而加载
3. 可以直接被类名调用，也可以被对象调用
4. 静态方法只能访问静态成员,无法从静态上下文中引用非静态，静态方法中不能使用this和super；

#### 静态代码块

1. 随着类的加载而“执行”，而且只执行一次。
2. 常用于给类进行初始化动作。

### 继承

**父类中的私有内容，子类是否具备？**
答：不用纠结是否继承。Java官方文档的解释：子类不能继承父类的私有属性，但是如果父类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的。

**对象实例化过程中成员变量的变化：**

默认初始化-父类初始化-显示初始化--构造代码块初始化--构造函数初始化（默父显块构）.
静态此处不讨论。

### super

1. 可以视为是父类的引用，子父类成员（变量+方法）同名时，super用来区分父类。

2. this和super在构造函数都只能定义在第一行，所以**只能二选一**。但即便是this(),也会在其他构造函数中调用super，父类必须先完成初始化。

   ![image-20200429231002524](/image-20200429231002524.png)

### @Override

方法重载：同一个类中，方法名相同，但参数列表不同（参数类型不同或个数不同，**和返回值以及修饰符无关**）
方法覆盖：发生在子父类中，子类重写父类的方法，方法名、参数列表都一样，jdk7开始，**返回值类型可以是原返回值的子类。**

注意点：

1. **子类覆盖的方法的权限必须大于等于父类**
2. **如果父类的方法是private,则不叫覆盖**，子类压根就不知道父类有这个方法，这叫子类自己建立了自己的方法。
3. 静态方法只能覆盖静态方法，也只能被静态方法覆盖。这个很少见。
4. 覆盖会打破封装性

### final

1. 类，不能被继承；
2. 方法，不能被覆盖；
3. 变量，基础数据类型为常量；引用数据类型为地址不可变，但所引用的对象可变。**而且都必须进行显示初始化.**

###  抽象类

> **abstract**：可以修饰==类、方法==

1. 可以有抽象方法，也可以有非抽象方法。有些抽象类中的非抽象方法是空实现，其实就是抽象方法。

2. 不能被实例化；

3. **有构造函数**；按照java设计原则，类的初始化过程必须包含父类初始化，所以虽然抽象类不能实例化，但应该有构造函数，可用于给子类初始化。

4. 不能同时存在：

   - private（私有化的方法就无法覆盖了，就一直抽象）
   - static（abstract static的方法又无实现，不合常理）
   - final（final修饰的类/方法不能被继承/覆盖,与abstract完全相冲）

   **注意：**abstract只修饰类和方法，所以当以下几个关键字修饰成员变量时是无关的。如:

   ```java
   public abstract class AbstrctDemo {
   
   	static final int i = 1;	// 合理	
       private int j;			// 合理
   }
   ```

### 接口

> 等于更加抽象开放的抽象类

1. ```java
   // 成员变量
   public static final int i = 10;
   // 成员方法
   public abstract xxx
   ```

2. 多实现，**接口之间**可以多继承。因为接口都是全抽象的，所以不存在调用的不确定性。
   注意以下情况：会出现覆盖的不合理

   ```java
   interface Interface01 {
   	void show();
   }
   
   interface Interface02 {
   	int show();
   }
   
   class Demo implements Interface01,Interface02{
   
   	@Override
   	public int show() {
   		return 0;
   	}
   }
   ```

3. **接口没有构造函数**

**接口与抽象类的区别：**抽象类多用来描述“类”，接口都用来描述“功能”，接口多实现的特点，也使其扩展性更强。

### 多态

> 1. 一个对象，多种类型。
> 2. 父类或者接口的引用指向其子类的对象

1. 转型

   - 向上转型（自动类型提升）

     ```java
     Animal a = new Dog();// 自动类型提升，a引用类型已经自动提升为Animal，所以Dog的特有功能已经无法访问.
     ```

   - 向下转型（类型强转）
     无论向上向下，至始至终都是**子类的对象在做引用类型的变化**。

2. instanceof
3. **成员的特点**：
   - 成员变量：编译运行都看左边（父类）（成员变量不存在多态性，更不会是覆盖）
   - 一般函数：编译看左边，运行看右边，（子类若没有就用父类的）
   - 静态函数：编译运行都看左边。（静态方法在静态区，直接被类名调用，不存在多态）

### 内部类

> 设计原因：可直接访问类中的私有成员。

1. 内部类无限制访问外部类，**外部类**必须**new 内部类对象**才能访问内部类成员

2. **外部**创建内部类

   - 非静态

     ```java
     Outer.Inner  in = new  Outer().new  Inner()
     ```

   - 静态

     ```java
     Outer.Inner  in = new  Outer.Inner()
     ```
   
3. 为什么可以直接访问外部类的成员？因为内部类持有外部类的引用。即：外部类名.this

4. 如果内部类中定义了静态成员，则内部类也必须是静态的。（静态成员随类的加载而加载）可以直接用类名调用：Outer.Inner.show()

5. 位置

   - 成员内部类
     1. 可以被成员修饰符修饰
   - 局部内部类
     1. 符合局部位置的特点，只能内部访问，在方法外不知道这个“局部内部类”的存在；
     2. **局部内部类访问它所在方法的局部变量/形参时，要求该局部变量必须声明为final的原因**：对象的生命周期往往会比局部变量的长，比如我们可以把局部内部类的对象指向给其他的引用，这样这个对象就可以一直生存着，而局部变量随着方法出栈就消失了。此时，如果我们在用这个存活的变量调用已经死了的局部变量就会报错。jdk8开始，会默认给这个情况的局部变量加上隐式final，但最好手动加上.
        形参也要加final

6. 匿名内部类
   其实就是匿名子类对象；
   格式：new 父类or接口（）{子类覆盖的方法+子类自身的方法}

​     