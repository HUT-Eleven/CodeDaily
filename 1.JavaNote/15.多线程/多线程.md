### 线程相关概念

```
进程：正在运行的程序，进程会使用内存空间和系统资源。

线程：一个进程中可能有多个执行任务，每个任务都是一个线程。每个线程也可以看做一条执行路径，线程是程序使用CPU的最基本单位。
```

```
jvm虚拟机的启动是多线程的：垃圾回收线程加上主线程，最低启动了两个线程.
```

```
run():仅仅是封装被线程执行的代码，直接调用是普通方法
start():首先启动了线程，然后再由jvm去调用该线程的run()方法。
```

```
多线程并非真的是多个线程同时执行，因为CPU在同一时间点只能执行一件事。
```



### 线程常用方法

##### 名称相关

```
getName()、setName(String name)
针对不是Thread类的子类：Thread.currentThread().getName()
也可以调用构造函数：Thread（名字）；
源码中的名称是：Thread-编号
```

##### 优先级

```
getPriority()、setPriority(1-10，默认是5)，高优先级仅代表获取CPU时间片的几率高。
```

##### 守护线程（用户线程）

```
setDaemon(boolean on)，当正在运行的线程只剩下守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。
```

##### 霸道线程    

```
join(...): 等待该线程终止。可以理解为“霸道线程”。必须在start()之后执行。
```

##### 中断线程

```
interrupt()：
```

##### 礼让线程

```
yield():，当一个线程抢到执行权后，执行到yield（）方法后，就会放弃执行权，但是不能靠它保证一人一次.
```

### 两种方式实现多线程

```html
方式一：继承Thread类

方式二：实现Runnable接口

实现Runnable接口的方式的好处：解决单继承的局限性；
<b>重点</b>同一资源的情况，方式一创建多个对象，会有多个资源。(体现在两者的创建多线程的方式不同,比如如果要让一个成员变量作为共享资源时，继承的方式只能选择让该成员变量加static，而实现Runnable接口的方式则不用，因为使用的是同一资源)
```



### 线程安全问题

#### 例子--卖票

```
继承Thread的方式：
    变量在run方法中，错误。合卖各的
    变量在成员但非静态。错误。合卖各的
    静态成员，错误。线程不安全
实现Runnable的方式：
	可以不用静态，所以推荐用这种方式实现多线程。
```



#### 原因

```
A:多线程环境 && B:存在共享数据  == 可能出现多线程安全问题（两者都为true时才存在，所以只需要更改其中一个即可使线程安全。）

栗子：卖票出现卖同一张票，或者卖出负数票。

补充：CPU的一次操作，是指这个动作是原子性的。例如：i--不是一个原子性的动作。
```

#### 同步机制synchronized

##### 同步机制的特点

```
多个线程用同一把锁。同步可以解决安全问题的根本原因就在这个锁上。
```

##### 三种同步情况

```
A:同步代码块
        synchronized(对象) {需要被同步的代码;}
        锁对象可以是任意对象。

B:同步方法
        一般放在访问修饰符后面，也可以放前面。
        锁对象是this

C:静态同步方法
        锁对象是当前类的字节码文件对象，因为你只有字节码文件，会静态方法加载之前。
        
小结：如果用同步代码块，我们一般就直接在run方法中使用，如果是使用（静态）同步方法就另外写一个方法，在run方法中调用这个方法。
```



##### 同步的弊端

```
当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。
```



#### 回顾线程安全的类


	Vector<E>
	Hashtable<K, V>
	
	原因是Collections提供了synchronizedXxx的方法可以把线程不安全的转为线程安全的：
	例如:public static <T> List<T> synchronizedList(List<T> list)

#### Lock

```
虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。
Lock lock = new ReentrantLock();//ReentrantLock是Lock的实现子类
void lock()： 获取锁。
void unlock():释放锁。 
try{
	lock.lock();
	......
}finally{
    lock.unlock();
}
```

#### 死锁

```java
两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象。
if (flag) {
	synchronized (MyLock.objA) {
		System.out.println("if objA");
			synchronized (MyLock.objB) {
				System.out.println("if objB");
			}
		}
} else {
	synchronized (MyLock.objB) {
		System.out.println("else objB");
			synchronized (MyLock.objA) {
				System.out.println("else objA");
			}
	}
}
```

### 生产者消费者

问题一：生产者/消费者多次执行

```
原因：生产者线程/消费者线程连续抢到CPU的执行权。
```

问题二：出现年龄和姓名不匹配

```
线程执行的原子性和随机性，生产者只更改了年龄，没来得及改姓名，消费者就直接打印出来了上次的结果。
```

解决方案：

```
加锁可以解决上诉两个问题。需注意的是生产者和消费者都要加锁，并且是加同一把锁。
```

##### 等待唤醒机制

```
加锁虽然解决了线程的安全问题，但是正常情况是生产一个，消费一个。所以可以使用等待唤醒机制来解决。
```

```
Object类中提供了三个方法：
        wait():等待
        notify():“	随机”唤醒单个线程
        notifyAll():唤醒所有线程
为什么这些方法不定义在Thread类中呢?
        这些方法的调用必须通过锁对象调用，而我们使用的锁对象可以是任意锁对象。所以，这些方法必须定义在Object类中。 			
```





### ThreadGroup线程组

```
把多个线程组合到一起，它可以对一批线程进行分类管理。
构造方法：ThreadGroup(String name)、ThreadGroup(ThreadGroup parent, String name) 
Thread中也有构造方法可以指定线程组。线程默认情况下都是属于main线程组
用法举例：
//通过组名称设置后台线程，表示该组的线程都是后台线程：
tg.setDaemon(true);

```

### 线程池Executors

```
好处：启动一个线程的成本是比较高的。线程池就是先创建好几个线程，线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
演示代码：
A:创建一个线程池对象，控制要创建几个线程对象。
    //public static ExecutorService newFixedThreadPool(int nThreads)
    ExecutorService pool = Executors.newFixedThreadPool(2);
B:这种线程池的线程可以执行：
	可以执行Runnable对象或者Callable对象代表的线程
	pool.submit(new MyRunnable());
	pool.submit(new MyRunnable());
c:结束线程池
	pool.shutdown();
```

#### Callable接口实现多线程

```
Callable:是带泛型的接口，实现Callable接口也可以实现多线程。这种方式是依赖于线程池存在的，因为该方式不能像Runnable接口一样，作为参数传入Thread中，实现多线程，具有局限性。这种方式只能依赖线程池存在。并且它的call方法（即类似run方法）时有返回值的，这是run方法没有的，返回值类型就是Callable的泛型类型。
```



### 匿名内部类形式实现多线程

```
一、// 继承Thread类来实现多线程
		new Thread() {
			public void run() {
				for (int x = 0; x < 100; x++) {
					System.out.println(Thread.currentThread().getName() + ":"
							+ x);
				}
			}
		}.start();

二、// 实现Runnable接口来实现多线程
		new Thread(new Runnable() {
			@Override
			public void run() {
				for (int x = 0; x < 100; x++) {
					System.out.println(Thread.currentThread().getName() + ":"
							+ x);
				}
			}
		}) {
		}.start();

三、同时实现Runnable和Thead中的run方法(结果：只会打印Thread中的run方法，但这种方式根本不可能会用到。)
		new Thread(new Runnable() {
			@Override
			//这是重写Runnale中的run方法
			public void run() {
				for (int x = 0; x < 100; x++) {
					System.out.println("hello" + ":" + x);
				}
			}
		}) {
			//这是重写Thread中的run方法
			public void run() {
				for (int x = 0; x < 100; x++) {
					System.out.println("world" + ":" + x);
				}
			}
		}.start();
```

### 多线程栗子——Timer定时器

```
Timer:定时器
TimerTask:任务
```

### sleep和wait方法的区别

```
sleep:--不释放锁;--必须指时间--是Thread类的方法
wait:--释放锁;--可以不指定时间，也可以指定时间--是Object的方法
```

### 为什么不用stop和suspend

```
stop原因：
	1. 主要还是因为设计的太暴力了，它会强制中断线程的执行，无论run方法是否执行完了。
	2. 并且还会释放这个线程所持有的所有的锁对象，这会导致不安全的情况。

栗子：比如转账A-500后，直接stop了，那么会导致事务还没回滚，而A的账户却被扣款了。
```

```
suspend原因：该方法本来是用来暂停线程的。它在暂停时会一直保持对锁的占有，导致它可能会造成死锁。（等于把自己所在房间里了，但还拿着钥匙。自闭）

栗子：假如有A，B两个线程，A线程在获得某个锁之后被suspend阻塞，这时A不能继续执行，线程B在或者相同的锁之后才能调用resume方法将A唤醒，但是此时的锁被A占有，B不能继续执行，也就不能及时的唤醒A，此时A，B两个线程都不能继续向下执行而形成了死锁。这就是suspend被弃用的原因。
```

